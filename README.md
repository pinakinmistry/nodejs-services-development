# NodeJS Services Development

## Express

Even though the req and res objects are generated by the http module and have all of the same functionality, Express decorates the req and res objects with additional functionality. By conflating Node core APIs with Express APIs on the same objects the principles of least surprise and separation of concerns are violated, while also causing performance issues.

## Fastify

## Lab 3.1

## Lab 3.2

## Serving web content

Static assets (content that does not change very often) should not be served by Node. Static content should be delivered via a CDN and/or a caching reverse proxy that specializes in static content such as NGINX or Varnish

Node.js could serve static content for applications with very small user bases that have a very low growth potential

Where Node.js shines however, is dynamic content. Using Node.js as a mediator for gathering data from multiple sources and rendering some output is perfect for such an evented language and non-blocking I/O platform

## Using templates with Fastify and HandlebarJS

Using three braces to denote an interpolation point is Handlebars syntax that instructs the template engine to conduct raw interpolation.

In other words, if the body template local contains HTML syntax the content will not be escaped whereas using two braces would cause HTML syntax to be escaped (for instance < would be escaped to &â€Œlt;). This should never be used when interpolating (uncleaned) user input into templates but when building a layout we need to inject raw HTML.

The body local is created automatically by point-of-view when rendering a view because we specified the layout option.

The point-of-view plugin that we registered in app.js decorated the reply instance with a view method. When we registered point-of-view, we set the root option to the views folder. Therefore, when we pass 'index.hbs' to reply.view it knows to look for index.hbs in the view folder. Similarly, the layout option that we set to 'layout.hbs' indicates to point-of-view that the layout template can be found in views/layout.hbs. So when we use reply.view here point-of-view first renders both the views/index.hbs file and then interpolates the rendered output into views/layout.hbs and sends the final rendered output of both files combined as the response. The return value of the reply.view method must be returned from the async function passed as the route handler so that Fastify knows when the route handler has finished processing the request.

## Serving static content and using templates with Express

The original focus of the Fastify framework was on building RESTful JSON services, whereas Express is more geared towards template rendering (and static serving static content). Therefore Express has these pieces built into its core whereas in Fastify template rendering is an add-on.

```cmd
npm install -g express-generator@4

express --hbs express-web-server

cd express-web-server
npm install

cd views
node -e "fs.openSync('hello.hbs', 'w')"
cd ..

cd routes
node -e "fs.renameSync('users.js', 'hello.js')"
cd ..

```

```js
// app.js

if (process.env.NODE_ENV !== 'production') {
  app.use(express.static(path.join(__dirname, 'public')));
}
```

express instance has a method named static which returns Express middleware that will serve requests that match up with any files in the public folder.

Now static hosting will only occur in development and production static hosting is left as a deployment infrastructure problem.

```js
// routes/index.js
var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index');
});
module.exports = router;
```

Express has res.render built-in to its core and it works in essentially the same way as reply.render added by the point-of-view plugin when registered in a Fastify server - although at the time of writing Express v4 renders at about half the speed of Fastify's point-of-view in production.

## Streaming with Fastify

```cmd
npm install hn-latest-stream
cd routes
node -e "fs.mkdirSync('articles')"
cd articles
node -e "fs.openSync('index.js', 'w')"
cd ..
cd ..
```

```js
return hnLatestStream(amount, type)
```

Returning the stream (the result of calling hnLatestStream) from the route handler instructs Fastify to safely pipe the stream to the response. The reply.send method can also be passed a stream and Fastify behaves in the same way - by piping the stream as the HTTP response.

Due to Fastify handling the stream for us, any errors in the stream will be handled and propagated. If we disconnect from the Internet and then attempt to access results in server error